---
layout: post
title:      "The Importance of Being Curious"
date:       2019-11-08 20:27:18 +0000
permalink:  the_importance_of_being_curious
---

So, how about those algorithms? Full disclosure, when I first heard the word “algorithm” I had school flashbacks. To be fair, algebra wasn't a struggle, and I enjoyed it, but still I prepared myself to memorise some formulas. Except, in this context, the algorithm is probably the thing *you* come up with. Or, the thing I come up with. Or, the thing I will maybe never perfect but at least I tried.

Trees, linked lists, bubble sort, linear search, Big O notation. For a bootcamp grad, that might seem like a lot of gibberish. You learned how to write code that gets the job done. Especially in web development, so much gets abstracted away. When you’ve made a few decent projects, you may wonder what the point is. Why do I need to know any of this? Is this actually important? Why am I struggling with the “easy” problems on Codewars/LeetCode/HackerRank when seasoned devs say this isn’t even relevant to their day-to-day work? Well, for a start those seasoned devs have learned a lot since they first learned these things. More importantly, this is the part where my advice to you comes in: **stay curious**.

First, I apologise if you were hoping for strategies or problem solutions. Considering the most frequent advice I hear is, “Just keep doing coding problems,” I don’t know that I have much to contribute on that front. However, I’ve found curiosity to be invaluable.

Interestingly enough, I first came across the curiosity-first approach as a relationship strategy. Especially in an argument, you’ll be much better off if you stay curious. Your partner isn’t the enemy, but someone you’re trying to understand. I’ve since realised it goes way beyond interpersonal relationships (but also, give that a try!). It would be pretty simple to say, “I don’t understand what a tree even is, I don’t need to know this, have we all abandoned the programmer-first utopia Matz envisioned?” That approach won’t get you very far, however, just frustrated and stuck.

So what happens when you get curious? Maybe you learn about George Boole, the namesake of the boolean data type. Maybe Boolean algebra really freaks you out because how can true and false get so complicated?? Maybe you learn that Ruby is written in C, and you realise that the kind soul who wrote it also wrote a bunch of methods for arrays so you don’t have to think about memory allocation. You don’t have to worry that when you manipulate an array, what is potentially happening in the background is that your array is actually being copied, with the changes you made, and then that variable you declared to keep track of your array is now pointing to that new array, leaving your old array lost and waiting to be written over.

So, seriously, what’s the point? Well, now you’re better informed about hidden costs. Some of the abstracted away processes may never be particularly relevant to a project, but at least you don’t think it’s magic anymore. You've had to think about it. Now you're thinking about efficiency for the computer *and* yourself. It gets you thinking how devs think. It improves your relationship with your computer. And in an industry where we're all, always, learning, it can't hurt to learn a little more.
